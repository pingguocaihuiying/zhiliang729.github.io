<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>images</title>
<script type="text/javascript">
function MM_swapImgRestore() { //v3.0
  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;
}
function MM_preloadImages() { //v3.0
  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();
    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)
    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}
}

function MM_findObj(n, d) { //v4.01
  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {
    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}
  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];
  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document);
  if(!x && d.getElementById) x=d.getElementById(n); return x;
}

function MM_swapImage() { //v3.0
  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)
   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}
}
</script>
<style type="text/css">
body,td,th {
	font-size: 36px;
}
#main {
	width: 1000px;
	align: center;
	margin: 0px auto;
}
</style>
</head>

<body >
<div id="main">
<p align="center">find命令</p>
<div>
  <p>find命令可以删除、复制、移动和执行其查找到的文件。另外，使用-exec参数可以根据您需要的命令序列来自动运行这些文件。它甚至可以在对任何文件执行这些操作前，进一步让您进行确认。</p>
  <div>
    <p><strong>find 命令格式</strong></p>
    <p>find   [起始目录]   寻找条件 操作<br />
      <br />
      有种表述方式：find PATH OPTION [-exec COMMAND { } \;</p>
    <p><br />
      find命令会根据我们给的option,也就是寻找条件从我们给出的目录开始对其中文件及其下子目录中的文件进行递归搜索，命令中的寻找条件可以是一个用逻辑运算符 not、and、or 组成的复合条件:</p>
    <div style="align:center; background-color:#0F9; margin:50px auto;" ><p>(1) and：逻辑与，在命令中用&ldquo;-a&rdquo;表示，是系统缺省的选项，表示只有当所给的条 件都满足时，寻找条件才算满足。例如：<br /><br />find –name &rsquo;tmp&rsquo; –xtype c -user &rsquo;inin&rsquo;<br /><br />% 该命令寻找三个给定条件都满足的所有文件<br /><br />(2) or：逻辑或，在命令中用&ldquo;-o&rdquo;表示。该运算符表示只要所给的条件中有一个满足 时，寻找条件就算满足。例如：<br /><br />find –name &rsquo;tmp&rsquo; –o –name &rsquo;mina*&rsquo;<br /><br />% 该命令查询文件名为&rsquo;tmp&rsquo;或是匹配&rsquo;mina*&rsquo;的所有文件。<br /><br />(3) not：逻辑非，在命令中用&ldquo;!&rdquo;表示。该运算符表示查找不满足所给条件的文件 。例如：<br /><br />find ! –name &rsquo;tmp&rsquo;<br /><br />% 该命令查询文件名不是&rsquo;tmp&rsquo;的所有文件。需要说明的是：当使用很多的逻辑选项时，可以用括号把这些选项括起来。为了避免Shell本身对括号引起误解，在话号前需要加转义字符&ldquo;\&rdquo;来去除括号的意义。例：<br /><br />find \(–name &rsquo;tmp&rsquo; –xtype c -user &rsquo;inin&rsquo; \) </p></div>
  </div>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <p><a rel="nofollow">简化文件系统的管理</a></p>
  <p>与大多数命令一样，find命令具有一长串令人生畏的选项和开关，它们会阻碍人们深入地学习该命令，但正是因为其范围广阔，真正的 Explorer 并不会被它们吓倒。一条好的通用原则在简化一个复杂问题时都会经过漫长的过程。启动一个终端，并尝试执行下面的命令：</p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="400" border="0">
      <tbody>
        <tr>
          <td><div align="center">
            <pre>$ find . -name *.gif -exec ls {} \;<br />
        </pre>
          </div></td>
        </tr>
      </tbody>
    </table>
  </div>
  <p>-exec 参数中包含了真正有价值的操作。当查找到匹配搜索条件的文件时，-exec参数定义了将对这些文件进行什么操作。该示例告诉计算机进行如下操作：</p>
  <ol>
    <li>从当前文件夹开始往下搜索，紧跟在find之后，使用点号.。</li>
    <li>定位所有名称以 .gif 结尾的文件（图形文件）。</li>
    <li>列出所有查找到的文件，使用ls命令。</li>
  </ol>
  <p>需要对-exec参数进行更深入地研究。当查找到匹配搜索条件的文件名时find命令执行ls {}字符串，用文件名和路径代替文本{}. 假设在搜索中查找到 saturn.gif 文件，find将执行如下所示的命令：</p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="400" border="0">
      <tbody>
        <tr>
          <td><pre>$ ls ./gif_files/space/solar_system/saturn.gif<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
  </div>
  <p>本文余下的内容建立在这条一般原则之上：仔细地使用find命令可以让 UNIX 文件系统的管理工作变得更加容易。例如，如果您使用了-fstype参数，find命令可以根据查找到的文件所处的文件系统的类型来对命令进行相应的处理。在find命令对查找到的文件执行相应命令前将对您进行提示，这通常是非常有用的，您可以使用-ok参数告诉它继续执行该操作，接下来我们将对其进行介绍。</p>
  <p><a rel="nofollow">可选的执行</a></p>
  <p>-ok是 -exec 参数的一个重要的替代项，它的行为和-exec一样，但它会提示您是否要对文件运行相应的命令。假设您想要删除 home 目录中的大部分 .txt 文件，但希望能够逐个文件地执行该操作。像 UNIX 中的rm命令那样的删除操作是很危险的，因为当使用像find这样的自动化处理方式来查找文件时，它可能一不小心会删除重要的文件，您也许希望在删除这些系统查找到的文件之前对其进行仔细检查。</p>
  <p>下面的命令列出了您的 home 目录中所有的 .txt 文件。要删除这些文件，必须在find 命令通过列出文件名提示您确认操作时输入Y 或者y：</p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="400" border="0">
      <tbody>
        <tr>
          <td><div align="center">
            <pre>$ find $HOME/. -name *.txt -ok rm {} \;<br />
        </pre>
          </div></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p>它列出了查找到的每个文件，并且系统将暂停以等待您输入Y或者y<u><strong>. 如果您按下 Enter 键，系统将不会删除该文件。(输入Y或者y，认为执行，n或者N或者Enter认为不执行)</strong></u><a rel="nofollow" href="http://www.ibm.com/developerworks/cn/aix/library/es-unix-find.html#listing1"><u>  <br />
  清单 1</u></a> 显示了一些示例结果：</p>
  <p><br />
    <br />
    <a rel="nofollow"><strong>清单 1. 示例结果</strong></a><br />
  </p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="572" border="0">
      <tbody>
        <tr>
          <td><pre>&lt; rm ... /home/bill/./.kde/share/apps/karm/karmdata.txt &gt; ?<br />&lt; rm ... /home/bill/./archives/LDDS.txt &gt; ?<br />&lt; rm ... /home/bill/./www/txt/textfile1.txt &gt; ?<br />&lt; rm ... /home/bill/./www/txt/faq.txt &gt; ?<br />&lt; rm ... /home/bill/./www/programs/MIKE.txt &gt; ?<br />&lt; rm ... /home/bill/./www/programs/EESTRING.txt &gt; ?<br />.<br />.<br />.<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p>系统将在每个问号之后暂停，在本示例中，每次都按下了 Enter 键以继续处理下一个文件。（没有删除任何文件。）-ok参数允许您控制每个查找到的文件的自动化处理过程，这样就添加了一种避免自动删除文件的安全措施。</p>
  <p>如果在使用-ok参数时涉及到过多的文件，那么一个好的方法是先运行带-exec的find命令以列出所有将要删除的文件，然后在经过检查确保其中不会删除重要的文件后，再次运行该命令，其中用rm代替ls。 -exec和-ok都非常有用，您必须确定在当前情况下哪一个能够更好的工作。请记住，安全第一！</p>
  <p><a rel="nofollow">创造性地使用 find</a></p>
  <p>您可以使用find命令执行各种各样的任务。本部分内容提供了使用find命令来管理文件系统的几种方式的示例。</p>
  <p>为了保持简单，这些示例都避免了使用涉及通过管道将一个命令的输出传递到另一个命令的-exec命令。然而，您完全可以根据自己需要在 find 命令的-exec子句中使用这样的命令。</p>
  <p><a rel="nofollow"><strong>清除临时文件</strong></a></p>
  <p>您可以使用find 命令来清除目录或子目录中在正常使用过程中生成的临时文件，这样可以节省磁盘空间。要实现该操作，请使用下面的命令：</p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="1000" border="0">
      <tbody>
        <tr>
          <td width="1295"><pre>$ find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p>括号中的<em><strong>文件掩码</strong></em> 标识出了需要删除的文件类型，每个文件掩码的前面都有-name. 该列表可以扩展为包括您需要清除的系统中的任何临时文件类型。在代码的编译和链接过程中，程序员及其工具会生成示例中的那些文件类型：a.out, *.o 和core. 其他的用户通常也会生成类似的临时文件，可以使用如*.tmp, *.junk等文件掩码来对命令进行相应的编辑。您可能还发现将命令放入一个称作clean的脚本中非常有用，当需要清除一个目录中的内容的时候就可以执行该脚本。</p>
  <p><a rel="nofollow"><strong>复制目录中的内容</strong></a></p>
  <p>find命令允许您复制目录中的全部内容，同时保持每个文件和子目录的权限、时间和所有权。要完成该操作，需要组合使用find和cpio命令，如下所示：</p>
  <p><br />
    <br />
    <a rel="nofollow"><strong>清单 2. 组合使用 find 和 cpio 命令</strong></a><br />
  </p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="572" border="0">
      <tbody>
        <tr>
          <td><pre>$ cd /path/to/source/dir<br /><br />$ find . | cpio -pdumv /path/to/destination/dir<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p>cpio命令是一个复制命令，它设计用来将文件复制到或复制出一个 cpio 或 tar 存档文件，并自动地保持文件和子目录的权限、时间和所有权。</p>
  <p><a rel="nofollow"><strong>列出文本文件的第一行内容</strong></a></p>
  <p>有些人使用每个文本文件的第一行作为标题或者文件内容的描述。可以使用列出文件名和所有文本文件第一行内容的报表更方便地对大量的文本文件进行筛选。下面的命令在报表中列出了您的 home 目录中所有文本文件的第一行内容，便于进一步地根据需要使用less命令进行检查：</p>
  <p><br />
    <br />
    <a rel="nofollow"><strong>清单 3. less 命令</strong></a><br />
  </p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="572" border="0">
      <tbody>
        <tr>
          <td><pre>$ find $HOME/. -name &quot;*.txt&quot; -exec head -n 1 {} \; &gt; report.txt<br /><br />$ less &lt; report.txt<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p><a rel="nofollow"><strong>维护 LOG 和 TMP 文件的存储空间</strong></a></p>
  <p>要为生成大量文件的应用程序维护 LOG 和 TMP 文件存储空间，可以将下列命令放入到每天运行的cron任务中：</p>
  <p><br />
    <br />
    <a rel="nofollow"><strong>清单 4. 维护 LOG 和 TMP 文件存储空间</strong></a><br />
  </p>
  <div align="center">
    <table width="1000" border="0" cellpadding="0" cellspacing="0">
      <tbody>
        <tr>
          <td width="1008"><pre>$ find $LOGDIR -type d -mtime +0 -exec compress -r {} \;<br /><br />$ find $LOGDIR -type d -mtime +5 -exec rm -f {} \;<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p>第一个命令找到 $LOGDIR 目录中所有包含在 24 小时内(-mtime +0) 进行了修改的数据的目录(-type d), 对它们进行压缩(compress -r {}) 以节省磁盘空间。如果这些目录超过了一个工作周(-mtime +5)，第二个命令则将其删除(rm -f {})，以便增加磁盘上的可用空间。通过这种方式，cron 任务自动地根据您所指定的时间窗口对目录进行维护。</p>
  <p>&nbsp;</p>
  <p><a rel="nofollow"><strong>复制复杂的目录树</strong></a></p>
  <p>如果您想要将复杂的目录树从一台计算机复制到另一台计算机，同时保持副本权限以及 User ID 和 Group ID（UID 和 GID——操作系统所使用的标记文件的所有权的数值），并且不复制用户文件，那么就需要再次使用find和cpio;</p>
  <p><br />
    <br />
    <a rel="nofollow"><strong>清单 5. 复制复杂的目录树</strong></a><br />
  </p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="572" border="0">
      <tbody>
        <tr>
          <td><pre>$ cd /source/directory<br /><br />$ find . -depth -print | cpio -o -O /target/directory<br />(-小写o  -大写O)
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p><a rel="nofollow"><strong>查找不指向任何地方的链接</strong></a></p>
  <p>要查找不指向任何地方的链接，可以使用带find的perl解释器，如下所示：</p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="400" border="0">
      <tbody>
        <tr>
          <td><pre>$ find / -type l -print | perl -nle '-e || print';<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p>该命令从最顶层目录 (/) 开始，列出由perl解释器确定不指向任何地方(-nle '-e || print')的所有链接(-type l -print)，关于 Unix Guru Universe 站点中这个技巧的更详细的信息。如果您想要删除这些文件，可以进一步使用管道将输出传递到rm -f {}命令。当然，Perl 可以在大多数的 UNIX 工具包中找到，它是许多功能强大的解释性语言工具中的一种。</p>
  <p><a rel="nofollow"><strong>定位和重命名无法打印的目录</strong></a></p>
  <p>在 UNIX 中，可能会有错误的或恶意的程序创建包含无法打印的字符的目录。定位和重命名这些目录，这样就可以更容易地检查并删除它们。要完成该操作，您首先需要在ls中包含-i开关，以获取该目录的索引节点的数值。然后，使用 find将索引节点的数值转换为一个可以使用mv命令进行重命名的文件名：</p>
  <p><br />
    <br />
    <a rel="nofollow"><strong>清单 6. 定位和重命名无法打印的目录</strong></a><br />
  </p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="572" border="0">
      <tbody>
        <tr>
          <td><pre>$ ls -ail<br /><br />$ find . -inum 211028 -exec mv {} newname.dir \;<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p><a rel="nofollow"><strong>列出长度为零的文件</strong></a></p>
  <p>要列出所有长度为零的文件，请使用下面的命令：</p>
  <div align="center">
    <table cellspacing="0" cellpadding="0" width="400" border="0">
      <tbody>
        <tr>
          <td><pre>$ find . -empty -exec ls {} \;<br />
        </pre></td>
        </tr>
      </tbody>
    </table>
    <br />
  </div>
  <p>在查找到空文件之后，您可以选择用rm命令来代替ls命令，以删除这些文件。</p>
  <p><strong>很明显，您对 UNIXfind命令的使用受到知识和创造性的限制</strong>。</p>
  <p><a rel="nofollow">结束语</a></p>
  <p>使用find命令，可以轻松地浏览 UNIX 文件系统中丰富的内容。很值得花时间来试验该命令，并了解它能为您做些什么。正如本文中所列出的示例，您可以通过许多创造性的方式来使用find, 这样可以轻松地浏览和管理文件系统，并且充满乐趣。</p>
</div>
<div>
  <div>
    <div>
      <h3>&nbsp;</h3>
      <h3>&nbsp;</h3>
      <h3>&nbsp;</h3>
      <h3>find命令详解      </h3>
    </div>
  </div>
</div>
<div></div>
<div></div>
<div> 用法总结如下：<br />
  find pathname -options [-print -exec -ok]<br />
  <br />
  pathname:查找路径<br />
  <br />
  -option:主要选项如下：<br />
  -name:按照文件名称查找<br />
  -perm：按照文件权限查找<br />
  -prune：不在当前指定的路径查找。如果同时指定了-depth选项,则prune被忽略<br />
  -user:按照文件属主查找<br />
  -group:按照文件属组查找<br />
  -mtime -n +n：按照文件更改时间查找。-n 指距离现在时间n天以内；+n n天以外<br />
  -nogroup:查找无效属组文件<br />
  -nouser:查找无效属主文件<br />
  -newer file1 !file2：查找更改时间比file1新比file2旧的文件<br />
  -type:查找某一类型文件<br />
  b:块设备文件<br />
  d:目录<br />
  c:字符设备文件<br />
  P：管道文件<br />
  l:符号链接文件<br />
  f:普通文件<br />
  -size n[c]查找文件长度为n块的文件 有[c]表示文件长度以字节计<br />
  -depth:查找时，首先查找当前目录文件，然后再在其子目录查找<br />
  -fstype：查找位于某一类型文件系统中的文件，文件系统类型可在/etc/fstab中找到<br />
  -mount:查找文件不跨越文件系统mount点<br />
  -follow:如遇到链接文件，则跟踪至链接所指向文件<br />
  -cpio:对匹配的文件使用cpio命令，将文件备份到磁带设备中 <br />
  <br />
  <br />
  -print:将匹配的文件输出到标准输出<br />
  <br />
  -exec:对匹配的文件执行所给的shell命令。形式为:command { } \;注意{ }和\;之间的空格<br />
  <br />
  -ok：和-exec作用相同。只不过以一种更安全的模式执行该参数所给的shell命令。在执行每个命令之前，都会给出提示，让用户确定是否执行
  <p><br />
  </p>
  <p><br />
  </p>
  <p><br />
    <strong>Linux中find常见用法示例</strong></p>
  <p>·find  path  -option  [  -print ]  [ -exec  -ok  command ]  {} \;<br />
    #-print 将查找到的文件输出到标准输出<br />
    #-exec  command  {} \;     -----将查到的文件执行command操作,{} 和 \;之间有空格<br />
    #-ok 和-exec相同，只不过在操作前要询用户</p>
  <p>====================================================</p>
  <p>-name  filename             #查找名为filename的文件<br />
    -perm                       #按执行权限来查找<br />
    -user   username            #按文件属主来查找<br />
    -group groupname            #按组来查找<br />
    -mtime  -n +n               #按文件更改时间来查找文件，-n指n天以内，+n指n天以前<br />
    -atime   -n +n              #按文件访问时间来查GIN: 0px&quot;&gt;-perm                        #按执行权限来查找<br />
    -user   username            #按文件属主来查找<br />
    -group groupname            #按组来查找<br />
    -mtime  -n +n               #按文件更改时间来查找文件，-n指n天以内，+n指n天以前<br />
    -atime   -n +n              #按文件访问时间来查找文件，-n指n天以内，+n指n天以前 <br />
    -ctime   -n +n              #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 <br />
    -nogroup                    #查无有效属组的文件，即文件的属组在/etc/groups中不存在<br />
    -nouser                     #查无有效属主的文件，即文件的属主在/etc/passwd中不存<br />
    -newer  f1 !f2              找文件，-n指n天以内，+n指n天以前 <br />
    -ctime   -n +n              #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 <br />
    -nogroup                    #查无有效属组的文件，即文件的属组在/etc/groups中不存在<br />
    -nouser                     #查无有效属主的文件，即文件的属主在/etc/passwd中不存<br />
    -newer  f1 !f2              #查更改时间比f1新但比f2旧的文件<br />
    -type    b/d/c/p/l/f        #查是块设备、目录、字符设备、管道、符号链接、普通文件<br />
    -size     n[c]              #查长度为n块[或n字节]的文件<br />
    -depth                      #使查找在进入子目录前先行查找完本目录<br />
    -fstype                     #查更改时间比f1新但比f2旧的文件<br />
    -type    b/d/c/p/l/f        #查是块设备、目录、字符设备、管道、符号链接、普通文件<br />
    -size     n[c]              #查长度为n块[或n字节]的文件<br />
    -depth                      #使查找在进入子目录前先行查找完本目录<br />
    -fstype                     #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到<br />
    -mount                      #查文件时不跨越文件系统mount点<br />
    -follow                     #如果遇到符号链接文件，就跟踪链接所指的文件<br />
    -cpio                %;     #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到<br />
    -mount                      #查文件时不跨越文件系统mount点<br />
    -follow                     #如果遇到符号链接文件，就跟踪链接所指的文件<br />
    -cpio                       #对匹配的文件使用cpio命令，将他们备份到磁带设备中<br />
    -prune                      #忽略某个目录</p>
  <p>====================================================<br />
    $find  ~  -name  &quot;*.txt&quot;  -print    #在$HOME中查.txt文件并显示<br />
    $find  .   -name  &quot;*.txt&quot;  -print<br />
    $find  .   -name  &quot;[A-Z]*&quot;  -pri26nbsp;   #对匹配的文件使用cpio命令，将他们备份到磁带设备中<br />
    -prune                              #忽略某个目录</p>
  <p>=====================================================<br />
    $find  ~  -name  &quot;*.txt&quot;  -print    #在$HOME中查.txt文件并显示<br />
    $find  .   -name  &quot;*.txt&quot;  -print<br />
    $find  .   -name  &quot;[A-Z]*&quot;  -print  #查以大写字母开头的文件<br />
    $find  /etc  -name  &quot;host*&quot;  -print #查以host开头的文件<br />
    $find  .  -name  &quot;[a-z][a-z][0--9][0--9].txt&quot;   -print  #查以两个小写字母和两个数字开头的txt文件<br />
    $find .  -perm  755  -print<br />
    $find  .  -perm -007  -exec ls -l {} \;  #查所有用户都可读写执行的文件同-perm 777<br />
    $find  . -type d  -print<br />
    $find  .  !  -type  d  -print <br />
    $find  .  -type l  -print</p>
  <p>$find  .  -size  +1000000c  -print       #查长度大于1Mb的文件<br />
    $find  .  -size  100c        -print      # 查长度为100c的文件<br />
    $find  .  -size  +10  -print             #查长度超过期作废10块的文件（1块=512字节）</p>
  <p>$cd /<br />
    $find  etc  home  apps   -depth  -print  | cpio  -ivcdC65536  -o  /dev/rmt0<br />
    $find  /etc -name &quot;passwd*&quot;  -exec grep  &quot;cnscn&quot;  {}  \;  #看是否存在cnscn用户<br />
    $find . -name &quot;yao*&quot;  | xargs file<br />
    $find  . -name &quot;yao*&quot;  |  xargs  echo   &quot;&quot; &gt; /tmp/core.log<br />
    $find  . -name &quot;yao*&quot;  | xargs  chmod  o-w</p>
  <p>======================================================</p>
  <p>find  -name april*                      在当前目录下查找以april开始的文件<br />
    find  -name  april*  fprint file        在当前目录下查找以april开始的文件，并把结果输出到file中<br />
    find  -name ap* -o -name may*  查找以ap或may开头的文件<br />
    find  /mnt  -name tom.txt  -ftype vfat  在/mnt下查找名称为tom.txt且文件系统类型为vfat的文件<br />
    find  /mnt  -name t.txt ! -ftype vfat   在/mnt下查找名称为tom.txt且文件系统类型不为vfat的文件<br />
    find  /tmp  -name wa* -type l           在/tmp下查找名为wa开头且类型为符号链接的文件<br />
    find  /home  -mtime  -2                 在/home下查最近两天内改动过的文件<br />
    find /home   -atime -1                  查1天之内被存取过的文件<br />
    find /home -mmin   +60                  在/home下查60分钟前改动过的文件<br />
    find /home  -amin  +30                  查最近30分钟前被存取过的文件<br />
    find /home  -newer  tmp.txt             在/home下查更新时间比tmp.txt近的文件或目录<br />
    find /home  -anewer  tmp.txt            在/home下查存取时间比tmp.txt近的文件或目录<br />
    find  /home  -used  -2                  列出文件或目录被改动过之后，在2日内被存取过的文件或目录<br />
    find  /home  -user cnscn                列出/home目录内属于用户cnscn的文件或目录<br />
    find  /home  -uid  +501                 列出/home目录内用户的识别码大于501的文件或目录<br />
    find  /home  -group  cnscn              列出/home内组为cnscn的文件或目录<br />
    find  /home  -gid 501                   列出/home内组id为501的文件或目录<br />
    find  /home  -nouser                    列出/home内不属于本地用户的文件或目录<br />
    find  /home  -nogroup                   列出/home内不属于本地组的文件或目录<br />
    find  /home   -name tmp.txt   -maxdepth  4  列出/home内的tmp.txt 查时深度最多为3层<br />
    find  /home  -name tmp.txt  -mindepth  3  从第2层开始查<br />
    find  /home  -empty                     查找大小为0的文件或空目录<br />
    find  /home  -size  +512k               查大于512k的文件<br />
    find  /home  -size  -512k               查小于512k的文件<br />
    find  /home  -links  +2                 查硬连接数大于2的文件或目录<br />
    find  /home  -perm  0700                查权限为700的文件或目录<br />
    find  /tmp  -name tmp.txt  -exec cat {} \;<br />
    find  /tmp  -name  tmp.txt  -ok  rm {} \;</p>
  <p>find   /  -amin   -10       # 查找在系统中最后10分钟访问的文件<br />
    find   /  -atime  -2         # 查找在系统中最后48小时访问的文件<br />
    find   /  -empty              # 查找在系统中为空的文件或者文件夹<br />
    find   /  -group  cat        # 查找在系统中属于 groupcat的文件<br />
    find   /  -mmin  -5         # 查找在系统中最后5分钟里修改过的文件<br />
    find   /  -mtime  -1        #查找在系统中最后24小时里修改过的文件<br />
    find   /  -nouser             #查找在系统中属于作废用户的文件<br />
    find   /  -user   fred       #查找在系统中属于FRED这个用户的文件<br />
     <br />
    查当前目录下的所有普通文件 <br />
    --------------------------------------------------------------------------------</p>
  <p># find . -type f -exec ls -l {} \; <br />
    -rw-r--r--    1 root     root        34928 2003-02-25  ./conf/httpd.conf <br />
    -rw-r--r--    1 root     root        12959 2003-02-25  ./conf/magic <br />
    -rw-r--r--    1 root     root          180 2003-02-25  ./conf.d/README <br />
    查当前目录下的所有普通文件，并在- e x e c选项中使用ls -l命令将它们列出</p>
  <p><br />
    =================================================<br />
    在/ l o g s目录中查找更改时间在5日以前的文件并删除它们：<br />
    $ find logs -type f -mtime +5 -exec  -ok  rm {} \;</p>
  <p><br />
    =================================================<br />
    查询当天修改过的文件<br />
    [root@book class]# find  ./  -mtime  -1  -type f  -exec  ls -l  {} \;</p>
  <p><br />
    =================================================<br />
    查询文件并询问是否要显示<br />
    [root@book class]# find  ./  -mtime  -1  -type f  -ok  ls -l  {} \;  <br />
    &lt; ls ... ./classDB.inc.php &gt; ? y<br />
    -rw-r--r--    1 cnscn    cnscn       13709  1月 12 12:22 ./classDB.inc.php<br />
    [root@book class]# find  ./  -mtime  -1  -type f  -ok  ls -l  {} \;  <br />
    &lt; ls ... ./classDB.inc.php &gt; ? n<br />
    [root@book class]#</p>
  <p>=================================================<br />
    查询并交给awk去处理<br />
    [root@book class]# who  |  awk  '{print $1&quot;\t&quot;$2}'<br />
    cnscn   pts/0</p>
  <p>=================================================<br />
    awk---grep---sed</p>
  <p>[root@book class]# df  -k |  awk '{print $1}' |  grep  -v  'none' |  sed  s&quot;/\/dev\///g&quot;<br />
    文件系统<br />
    sda2<br />
    sda1<br />
    [root@book class]# df  -k |  awk '{print $1}' |  grep  -v  'none'<br />
    文件系统<br />
    /dev/sda2<br />
    /dev/sda1<br />
     <br />
     <br />
    1)在/tmp中查找所有的*.h，并在这些文件中查找&ldquo;SYSCALL_VECTOR&quot;，最后打印出所有包含&quot;SYSCALL_VECTOR&quot;的文件名</p>
  <p>A) find  /tmp  -name  &quot;*.h&quot;  | xargs  -n50  grep SYSCALL_VECTOR<br />
    B) grep  SYSCALL_VECTOR  /tmp/*.h | cut   -d':'  -f1| uniq &gt; filename<br />
    C) find  /tmp  -name &quot;*.h&quot;  -exec grep &quot;SYSCALL_VECTOR&quot;  {}  \; -print</p>
  <p><br />
    2)find / -name filename -exec rm -rf {} \;<br />
       find / -name filename -ok rm -rf {} \;</p>
  <p><br />
    3)比如要查找磁盘中大于3M的文件：<br />
    find . -size +3000k -exec ls -ld {} ;</p>
  <p><br />
    4)将find出来的东西拷到另一个地方<br />
    find *.c -exec cp '{}' /tmp ';'</p>
  <p>如果有特殊文件，可以用cpio，也可以用这样的语法：<br />
    find dir -name filename -print | cpio -pdv newdir</p>
  <p><br />
    6)查找2004-11-30 16:36:37时更改过的文件<br />
    # A=`find ./ -name &quot;*php&quot;` |  ls -l --full-time $A 2&gt;/dev/null | grep &quot;2004-11-30 16:36:37&quot;</p>
</div>
<br />
<p align="center"><a href="../index.html">返回首页
</a></p>
</div>
</body>
</html>
